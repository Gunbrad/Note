下面给你一套**最小改动、效果稳定**的实现方案，目标是：**先筛选、后点排序，能够只对“当前可见行”排序**（且保持你“单列排序”的限制），并把排序/筛选的可见顺序正确映射到编辑保存。

---

# 核心思路

1. **把“当前可见的行”做成状态**（保存为一组“原始行索引”），筛选时只更新这组可见行；
2. **渲染统一走一条管线**：基于源缓存（`sourceFrozenCells/sourceScrollableCells`）→ 取“可见行集合”→ 应用当前列的排序状态（若有）→ 输出到 LiveData。
3. **排序只更新列的排序状态**，然后走这条统一渲染管线（因此无论是否筛选，排序都基于“可见行集合”）。
4. 修一处**稳定 ID（rowKey）**的小坑：你当前在 `emitGridInOrder()` 里用 `oldRow` 直接索 `originalRowOrder`，在“传入的是过滤后 grid”的情况下会错。应使用该行第一个单元格自带的**原始行号**生成 rowKey，这样过滤/排序都稳定、不抖动。
5. **更新 `currentRowOrder`**：在每次渲染时（筛选/排序后）按“显示顺序 → 原始行索引”重建映射，保证 `updateCellValue()` 的“显示行→原始行”保存逻辑持续正确。

---

# 需要新增/修改的字段

```java
// 当前可见的“原始行索引”；null 代表未筛选（全部可见）
private List<Integer> activeVisibleRows = null;
```

---

# 关键改动（一）：修复 emitGridInOrder 的 rowKey 计算

> 现在当你传入的是“过滤后 grid + identity order”时，`oldRow` 是过滤后索引，不是原始索引，导致稳定 ID 错位。改为从该行单元格上读原始行号作为 rowKey。

```java
private void emitGridInOrder(List<List<Cell>> grid, int[] rowOrder) {
    List<Cell> newFrozen = new ArrayList<>();
    List<Cell> newScrollable = new ArrayList<>();
    int rows = grid.size();
    int cols = rows > 0 ? grid.get(0).size() : 0;

    for (int newRow = 0; newRow < rows; newRow++) {
        int oldRow = rowOrder[newRow];
        if (oldRow >= 0 && oldRow < rows) {
            List<Cell> oldRowCells = grid.get(oldRow);

            // ✅ 用该行原始行号作为 rowKey，避免过滤后错位
            int rowKey;
            if (oldRowCells != null && !oldRowCells.isEmpty()) {
                rowKey = oldRowCells.get(0).getRowIndex(); // 这就是原始行索引
            } else {
                rowKey = oldRow; // 兜底
            }

            for (int c = 0; c < cols; c++) {
                if (c < oldRowCells.size()) {
                    Cell copied = createDisplayCopy(oldRowCells.get(c), newRow, rowKey);
                    if (c == 0) newFrozen.add(copied);
                    else newScrollable.add(copied);
                }
            }
        }
    }

    newFrozen.sort(Comparator.comparingInt(Cell::getRowIndex));
    newScrollable.sort((a, b) -> {
        int cmp = Integer.compare(a.getRowIndex(), b.getRowIndex());
        if (cmp != 0) return cmp;
        return Integer.compare(a.getColIndex(), b.getColIndex());
    });

    _frozenColumnCells.postValue(newFrozen);
    _scrollableColumnsCells.postValue(newScrollable);
}
```

---

# 关键改动（二）：统一的“筛选+排序”渲染管线

新增一个私有方法，**每次筛选或排序时只调用它**：

```java
private void refreshViewRespectingFilterAndSort() {
    int rows = totalRowsFromSource();
    int cols = totalColsFromColumns();
    if (rows <= 0 || cols <= 0) {
        _frozenColumnCells.postValue(new ArrayList<>());
        _scrollableColumnsCells.postValue(new ArrayList<>());
        _rowCount.postValue(0);
        currentRowOrder = new int[0];
        return;
    }

    // 1) 基于源缓存重建完整网格
    List<List<Cell>> grid = buildFullGrid(sourceFrozenCells, sourceScrollableCells, rows, cols);

    // 2) 取“候选行”（可见行）：筛选生效时用 activeVisibleRows，否则 0..rows-1
    List<Integer> candidates = new ArrayList<>();
    if (activeVisibleRows != null) {
        candidates.addAll(activeVisibleRows);
    } else {
        for (int i = 0; i < rows; i++) candidates.add(i);
    }

    // 3) 默认顺序 = 原始插入顺序（基于 originalRowOrder）
    candidates.sort((r1, r2) -> {
        int k1 = (originalRowOrder != null && r1 < originalRowOrder.length) ? originalRowOrder[r1] : r1;
        int k2 = (originalRowOrder != null && r2 < originalRowOrder.length) ? originalRowOrder[r2] : r2;
        return Integer.compare(k1, k2);
    });

    // 4) 若当前有排序状态，则在“候选行”上应用排序
    Column sortedCol = getSortedColumnDef();
    if (sortedCol != null) {
        final int sortCol = sortedCol.getColumnIndex();
        final boolean desc = "DESC".equals(sortedCol.getSortOrder());
        candidates.sort((r1, r2) -> {
            String s1 = getCellContent(grid.get(r1).get(sortCol));
            String s2 = getCellContent(grid.get(r2).get(sortCol));
            if (s1.isEmpty() && s2.isEmpty()) return 0;
            if (s1.isEmpty()) return 1;   // 空值末尾
            if (s2.isEmpty()) return -1;
            int c = compareExcelStyleNonEmpty(s1, s2);
            return desc ? -c : c;
        });
    }

    // 5) 构建“可见 grid”，并更新 currentRowOrder（显示行 -> 原始行）
    List<List<Cell>> viewGrid = new ArrayList<>(candidates.size());
    currentRowOrder = new int[candidates.size()];
    for (int i = 0; i < candidates.size(); i++) {
        int ori = candidates.get(i);
        viewGrid.add(grid.get(ori));
        currentRowOrder[i] = ori;
    }

    // 6) 发射（identity order，因为 viewGrid 已按显示顺序排列）
    int[] order = new int[viewGrid.size()];
    for (int i = 0; i < order.length; i++) order[i] = i;

    emitGridInOrder(viewGrid, order);
    _rowCount.postValue(viewGrid.size());
    markAsModified();
}

@Nullable
private Column getSortedColumnDef() {
    List<Column> cs = _columns.getValue();
    if (cs == null) return null;
    for (Column c : cs) {
        String so = c.getSortOrder();
        if (so != null && !so.isEmpty()) return c;
    }
    return null;
}
```

---

# 关键改动（三）：排序函数改为“只更新状态 → 统一渲染”

把 `sortByColumn()` 简化为：**重置其它列排序状态，设置当前列的排序状态，然后调用上面的 `refreshViewRespectingFilterAndSort()`**。

```java
public void sortByColumn(int columnIndex, @Nullable String sortOrder) {
    Integer rows = _rowCount.getValue();
    Integer cols = _columnCount.getValue();
    if (rows == null || cols == null || rows < 0 || cols <= 0) return;

    // 只做“单列排序状态管理”
    List<Column> colsDef = _columns.getValue();
    if (colsDef != null) {
        for (Column c : colsDef) {
            c.setSortOrder(c.getColumnIndex() == columnIndex ? sortOrder : null);
        }
        _columns.postValue(colsDef);
    }

    // 统一渲染（会对 activeVisibleRows 这批“可见行”应用排序/恢复默认顺序）
    refreshViewRespectingFilterAndSort();
}
```

> 说明：当 `sortOrder` 为空或 `null` 时，`refreshViewRespectingFilterAndSort()` 会退回“原始插入顺序”。

---

# 关键改动（四）：筛选函数只负责“算出可见行集合”，然后统一渲染

以你已经在用的“多值筛选”为例，把尾部替换为**记录可见行 + 统一渲染**：

```java
public void filterByColumnValues(int columnIndex, Set<String> selectedValues) {
    // 1) 空集合或“全选” => 清除筛选
    if (selectedValues == null || selectedValues.isEmpty()) {
        activeVisibleRows = null;
        refreshViewRespectingFilterAndSort();
        return;
    }

    // 2) 用源缓存计算该列所有值
    List<Cell> allSourceCells = getSourceCells();
    if (allSourceCells.isEmpty()) return;

    Set<String> allColumnValues = new HashSet<>();
    for (Cell cell : allSourceCells) {
        if (cell.getColIndex() == columnIndex) {
            allColumnValues.add(cell.getContent() != null ? cell.getContent() : "");
        }
    }
    if (selectedValues.containsAll(allColumnValues)) {
        activeVisibleRows = null;
        refreshViewRespectingFilterAndSort();
        return;
    }

    // 3) 求可见的“原始行索引”
    Set<Integer> valid = new HashSet<>();
    for (Cell cell : allSourceCells) {
        if (cell.getColIndex() == columnIndex) {
            String v = cell.getContent() != null ? cell.getContent() : "";
            if (selectedValues.contains(v)) valid.add(cell.getRowIndex());
        }
    }

    // 4) 记录为状态 + 渲染（排序会在渲染阶段应用）
    activeVisibleRows = new ArrayList<>(valid);
    refreshViewRespectingFilterAndSort();
}
```

> 你的另一个 `filterByColumn(..., min, max)`（范围筛选）建议也改造成**同样思路：只算出可见行，然后 `refreshViewRespectingFilterAndSort()`**。如果短期不改仓库层，也可以在仓库结果回调里把 `result` 里的 `rowIndex` 去重得到 `activeVisibleRows`，然后直接忽略回调里拼的 `newFrozen/newScrollable`，转而调用 `refreshViewRespectingFilterAndSort()`。

---

# 关键改动（五）：保持状态的一些细节

* **清除筛选**：提供一个小方法，UI 全选/清除时调用。

  ```java
  public void clearFilter() {
      activeVisibleRows = null;
      refreshViewRespectingFilterAndSort();
  }
  ```

* **reapplyCurrentSort()**：可简化为：

  ```java
  private void reapplyCurrentSort() { 
      refreshViewRespectingFilterAndSort(); 
  }
  ```

  （如果你在其他地方想“保持当前排序+筛选”的显示，直接调它即可。）

* **重新加载数据**：如果你把 `reloadData()` 保留为从仓库重拉，建议在 `loadCellData()` 数据到位后**不要直接按原顺序 emit**，而是最后调用 `refreshViewRespectingFilterAndSort()`（此时 `activeVisibleRows == null`，就是全量+当前排序状态）。

---

# 这样做能解决哪些现有问题

1. ✅ **筛选后点排序**：排序只应用到 `activeVisibleRows`，不会把被隐藏的行也拿来排序、导致“筛选失效”。
2. ✅ **稳定 ID 抖动**：用“该行第一个单元格的原始行号”作为 `rowKey`，过滤后的 identity order 不会再错位。
3. ✅ **编辑保存仍正确**：每次渲染后重建 `currentRowOrder`，`updateCellValue()` 的“显示行 → 原始行”映射持续有效（筛选/排序都 OK）。
4. ✅ **行为一致性**：无论是筛选、重排、清除筛选、再重排，都走同一套渲染逻辑，避免分叉代码引入时序 bug。

---

# 最后给几个“拿来就测”的用例

* **用例 1：** 先 `filterByColumnValues(2, {"已完成"})`，再 `sortByColumn(3, "DESC")`
  期望：仅“已完成”的行，按照第 4 列降序显示，空值仍在末尾。

* **用例 2：** 先 `sortByColumn(1, "ASC")`，再 `filterByColumnValues(1, {"A", "B"})`
  期望：只看值为 A/B 的行，仍保留“按第 2 列升序”的顺序。

* **用例 3：** 清除排序 `sortByColumn(1, null)`，保持筛选不变
  期望：回到原始插入顺序（按 `originalRowOrder`），但仍只显示当前筛选的行。

* **用例 4：** 在筛选+排序后编辑单元格
  期望：保存日志打印的 `(originalRow, col)` 坐标对应原始数据行，不会错存。

---

如果你把以上几处改动交给 Claude 按片段落地（特别是第①②③条），你的“筛选后排序”就会自然生效，而且编辑、刷新、清除筛选都能保持一致的行为。需要我把“范围筛选版”的可见行计算也改成同样风格的代码片段，我可以直接补上。
