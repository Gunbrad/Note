太好了，你的“5 列缓冲”思路可以精准绕开最后两列导致的列头/单元格不同步问题。下面给你一个可直接落地的实现方案，分两步走，并把\*\*第一步（最关键：缓冲列不给单元格）\*\*的改动写成可粘贴的代码片段。第二步（隐藏缓冲列列头）也给出最小改动方案，等你喊开始就能落地。

---

# 总体设计要点

* 引入\*\*5 个“缓冲列（build1…build5）”\*\*的概念：

  * 它们**永远排在最后**；
  * **参与水平滚动的宽度与事件**（因为在列列表中存在）；
  * **不产生任何单元格数据**（不在 LiveData 中发射单元格；保存到 DB 时也会被过滤），因此不会影响真实数据；
  * 第一步先**显示列头**；第二步再**隐藏列头**（仅头部隐藏，列本身仍存在参与滚动）。
* 兼容新增/插入列与新增/插入行：

  * **新增/插入列**一律插在“最后一个真实列”和“build1”之间；
  * **新增/插入行**时**跳过**缓冲列，不为其创建单元格。
* 渲染与保存：

  * 渲染时**不向 `_frozenColumnCells/_scrollableColumnsCells` 发射任何缓冲列的单元格**；
  * 保存时再次**过滤**缓冲列，确保“缓冲列无单元格”的约束被牢牢兜底。

---

# 需要新增的工具方法与常量（放到 `NoteViewModel` 内）

```java
// ====== 构建5列缓冲（build列）的常量与工具 ======
private static final int BUILD_BUFFER_COUNT = 5;
private static final String BUILD_PREFIX = "build"; // 列名 build1..build5
private boolean buildHeaderHidden = false; // 第二步用，第一步保持 false

private boolean isBuildColumnName(@Nullable String name) {
    return name != null && name.startsWith(BUILD_PREFIX);
}

private boolean isBuildColumn(@Nullable Column c) {
    return c != null && isBuildColumnName(c.getName());
}

private boolean isBuildColumnIndex(int idx) {
    List<Column> cs = _columns.getValue();
    return cs != null && idx >= 0 && idx < cs.size() && isBuildColumn(cs.get(idx));
}

private int firstBuildIndex(@Nullable List<Column> cols) {
    if (cols == null) return -1;
    for (int i = 0; i < cols.size(); i++) {
        if (isBuildColumn(cols.get(i))) return i;
    }
    return -1;
}

/**
 * 确保尾部存在5个 build 列；若不存在则创建；若位置不对则移到末尾。
 * showHeaders=true 表示显示列头；第二步隐藏时设为 false（见后）。
 */
private void ensureTrailingBuildColumns(boolean showHeaders) {
    List<Column> cols = _columns.getValue();
    if (cols == null) cols = new ArrayList<>();

    // 1) 先拿出已有的 build 列
    List<Column> builds = new ArrayList<>();
    for (Column c : cols) if (isBuildColumn(c)) builds.add(c);
    cols.removeIf(this::isBuildColumn);

    // 2) 补齐/重建 build1..build5
    builds.sort(Comparator.comparingInt(Column::getColumnIndex)); // 顺手稳定一下
    if (builds.size() != BUILD_BUFFER_COUNT) builds.clear();
    if (builds.isEmpty()) {
        for (int i = 0; i < BUILD_BUFFER_COUNT; i++) {
            Column b = new Column();
            b.setColumnIndex(-1);     // 先占位，稍后统一重排
            b.setName(BUILD_PREFIX + (i + 1)); // build1..build5
            b.setWidth(150);
            b.setType("BUFFER");      // 用 type 标识：UI 可按需处理（第二步隐藏头）
            b.setVisible(true);       // 第一阶段：需要显示列头
            b.setFrozen(false);
            builds.add(b);
        }
    } else {
        // 已存在则规范化属性
        for (int i = 0; i < builds.size(); i++) {
            Column b = builds.get(i);
            b.setType("BUFFER");
            b.setVisible(true);        // 第一步：列头可见
            b.setFrozen(false);
            b.setName(BUILD_PREFIX + (i + 1));
        }
    }

    // 3) 把真实列排前，build 列追加到末尾，并重新编号
    List<Column> merged = new ArrayList<>(cols);
    merged.addAll(builds);
    for (int i = 0; i < merged.size(); i++) merged.get(i).setColumnIndex(i);

    _columns.postValue(merged);
    _columnCount.postValue(merged.size());
}

/** 空白笔记：只放5个 build 列在末尾（此时没有真实列） */
private void setupBuildColumnsForBlankNote() {
    List<Column> cols = new ArrayList<>();
    for (int i = 0; i < BUILD_BUFFER_COUNT; i++) {
        Column b = new Column();
        b.setColumnIndex(i);
        b.setName(BUILD_PREFIX + (i + 1));
        b.setWidth(150);
        b.setType("BUFFER");
        b.setVisible(true);   // 第一步：显示列头
        b.setFrozen(false);
        cols.add(b);
    }
    _columns.postValue(cols);
    _columnCount.postValue(cols.size());
    _rowCount.postValue(0);

    // 单元格数据置空；源缓存清空
    _frozenColumnCells.postValue(new ArrayList<>());
    _scrollableColumnsCells.postValue(new ArrayList<>());
    sourceFrozenCells.clear();
    sourceScrollableCells.clear();
}
```

---

# 第一阶段（现在要实现）：

## A. 创建空笔记时自动添加 5 个 build 列（显示列头；无单元格）

**改动 1：`createBlankNotebook` 成功回调里**，清空后立刻放入 5 个 build 列。

```java
// 创建笔记本成功后
_currentNotebook.postValue(notebook);
// 初始化空表格数据（保持）
initializeEmptyTableData();
// 追加：空白表只放5个build列（列头可见，无单元格）
setupBuildColumnsForBlankNote();
```

**改动 2：`loadTableData()`** 当没有历史列时，不再创建“5x5”的默认数据，改为只放 5 个 build 列。

```java
if (columns != null && !columns.isEmpty()) {
    _columns.postValue(columns);
    // 保持原逻辑加载单元格
    loadCellData(notebookId);
} else {
    Log.d(TAG, "No existing columns found, creating 5 trailing build columns");
    setupBuildColumnsForBlankNote();
    _isLoading.postValue(false);
}
```

**改动 3：任何结构变动后保持 build 列永远在末尾**
在这些位置的末尾调用一次 `ensureTrailingBuildColumns(true)`：

* `addNewColumn()`
* `insertColumnAt(int position)`
* `deleteColumn(...) / deleteColumnAt(...)`
* `initializeTableData(...)`（如果你还会用到它）
* `loadTableData(...)` 成功分支（已有列）里也可调用以兜底（会把历史中已经存在的 build 列移到末尾/补齐缺失）。

> ⚠️ 只要你在**每次结构调整后**调用 `ensureTrailingBuildColumns(true)`，build1..5 就一定在末尾，不会影响用户的真实列创建。

示例（在 `addNewColumn()` 开头或末尾加一行即可）：

```java
public void addNewColumn() {
    ensureTrailingBuildColumns(true); // 兜底确保存在与位置正确
    List<Column> currentColumns = _columns.getValue();
    if (currentColumns == null) currentColumns = new ArrayList<>();

    // 真实列应插在第一个 build 之前
    int insertAt = firstBuildIndex(currentColumns);
    if (insertAt < 0) insertAt = currentColumns.size();

    // 将所有 build 列索引+1，给新列让位
    for (Column c : currentColumns) {
        if (isBuildColumn(c)) c.setColumnIndex(c.getColumnIndex() + 1);
    }

    Column newColumn = new Column();
    newColumn.setColumnIndex(insertAt);
    newColumn.setName("列" + (insertAt + 1));
    newColumn.setWidth(150);
    newColumn.setType("TEXT");
    newColumn.setVisible(true);
    newColumn.setFrozen(false);

    currentColumns.add(insertAt, newColumn);

    // 统一重排索引
    for (int i = 0; i < currentColumns.size(); i++) {
        currentColumns.get(i).setColumnIndex(i);
    }
    _columns.postValue(currentColumns);
    _columnCount.postValue(currentColumns.size());

    // 为新列创建单元格（只对真实列；build 列绝不创建）
    Integer rows = _rowCount.getValue();
    if (rows != null) {
        List<Cell> scrollable = _scrollableColumnsCells.getValue();
        if (scrollable == null) scrollable = new ArrayList<>();
        for (int r = 0; r < rows; r++) {
            Cell nc = new Cell();
            nc.setRowIndex(r);
            nc.setColIndex(insertAt);
            nc.setContent("");
            scrollable.add(nc);
            // 同步到源缓存
            sourceScrollableCells.add(createCellCopy(nc));
        }
        _scrollableColumnsCells.postValue(scrollable);
    }

    markAsModified();
    // 再兜一层，确保build仍在末尾（可选）
    ensureTrailingBuildColumns(true);
}
```

## B. 核心：**缓冲列不产生单元格**

**改动 4：新增/插入行时跳过 build 列**

在 `addNewRow()` 里，把这段：

```java
for (int col = 1; col < currentCols; col++) {
    // ...
}
```

替换为：

```java
for (int col = 1; col < currentCols; col++) {
    if (isBuildColumnIndex(col)) continue; // 跳过 build 列
    Cell newCell = new Cell();
    newCell.setRowIndex(newRowIndex);
    newCell.setColIndex(col);
    newCell.setContent("");
    scrollableCells.add(newCell);

    // 同步源缓存
    sourceScrollableCells.add(createCellCopy(newCell));
}
```

同理，在 `insertRowAt(int position)` 中对可滚动列插入时也要 **跳过 build 列**（两处：插入新单元格循环 & 源缓存插入循环）。

**改动 5：渲染时不向 LiveData 发射 build 列的单元格**

在 `emitGridInOrder(...)` 的双层 for 中，发射每一列时加过滤：

```java
for (int c = 0; c < cols; c++) {
    if (isBuildColumnIndex(c)) {
        // build 列：不发射任何单元格，保证“没有单元格”
        continue;
    }
    if (c < oldRowCells.size()) {
        Cell copied = createDisplayCopy(oldRowCells.get(c), newRow, rowKey);
        if (c == 0) {
            newFrozen.add(copied);
        } else {
            newScrollable.add(copied);
        }
    }
}
```

> 这样发射到 `_scrollableColumnsCells/_frozenColumnCells` 的列表里**不存在**任何属于 build 列的单元格对象。UI 仍然会显示列头（来自 `_columns`），但行区域不会有这些列的“格子对象”，完全满足\*\*“build 列不具备单元格”\*\*的要求。

**改动 6：保存到数据库前再做一次过滤兜底**

在 `saveCellsData(...)` 收集 `allCells` 之前，直接忽略 build 列：

```java
// 收集冻结列单元格
List<Cell> frozenCells = _frozenColumnCells.getValue();
if (frozenCells != null) {
    for (Cell cell : frozenCells) {
        if (isBuildColumnIndex(cell.getColIndex())) continue; // 过滤 build
        cell.setNotebookId(notebookId);
        allCells.add(cell);
    }
}

// 收集可滚动列单元格
List<Cell> scrollableCells = _scrollableColumnsCells.getValue();
if (scrollableCells != null) {
    for (Cell cell : scrollableCells) {
        if (isBuildColumnIndex(cell.getColIndex())) continue; // 过滤 build
        cell.setNotebookId(notebookId);
        allCells.add(cell);
    }
}
```

**改动 7：编辑保护（可选但推荐）**
在 `updateCellValue(int row, int col, String value)` 顶部加入：

```java
if (isBuildColumnIndex(col)) {
    Log.d(TAG, "Ignore edits on build column: col=" + col);
    return; // build 列不允许编辑
}
```

**改动 8：排序/筛选保护（可选）**
在 `sortByColumn(...)` 的最前面短路：

```java
if (isBuildColumnIndex(columnIndex)) return;
```

在筛选相关（如 `filterByColumn(...)`/`filterByColumnValues(...)`）前面也可短路，避免对 build 列进行筛选统计。

---

# 第二阶段（之后再做）：隐藏 build 列的列头（仍参与水平滚动）

目的：列头不显示文本，但 build 列依然存在于 `_columns` 里，保持水平拖拽缓冲生效。

**最小改动方案（ViewModel 侧准备方法 + UI 侧小改一处）：**

1. 在 ViewModel 内加入一个切换方法（只做“标记”，不删除列也不改顺序）：

```java
/** 隐藏/显示 build 列列头（不影响列本身参与滚动） */
public void setBuildHeadersHidden(boolean hidden) {
    buildHeaderHidden = hidden;
    List<Column> cols = _columns.getValue();
    if (cols == null) return;
    for (Column c : cols) {
        if (isBuildColumn(c)) {
            // 用 type 作为轻量信号，UI header 渲染时据此隐藏标题文本
            c.setType(hidden ? "BUFFER_HIDDEN" : "BUFFER");
            // 仍保持 c.setVisible(true)，确保列参与宽度与滚动
        }
    }
    _columns.postValue(cols);
}
```

2. UI/Header 绘制处（Adapter 或 Compose/自定义 View 的标题渲染逻辑）：

   * 若 `column.getType().equals("BUFFER_HIDDEN")`：**不绘制标题文本**（或把 TextView 设为空字符串），但仍给此列保留既定宽度；
   * 其他情况照常渲染。

> 这样做不需要改数据库结构，不会影响缓冲列参与拖拽；只是“视觉隐藏”列头。

---

# 行为验收（第一步）

* 新建空表：仅显示标题栏 `build1 build2 build3 build4 build5`；行区域无单元格（因为没有真实列也不为 build 列发射单元格）。
* 新增“真实列”两次后：标题栏显示
  `列1 列2 build1 build2 build3 build4 build5`
  行区域只对“列1/列2”生成单元格，“build1..5”下方没有单元格对象（UI会呈现空白）。
* 新增/插入行：只为真实列补单元格；build 列永远不产生单元格。
* 保存：不会向 DB 写入任何 build 列的单元格。
* 水平拖拽：因为末尾多了 5 列参与滚动宽度，滑到最右侧时不再出现“列头/单元格不同步”的视觉错位。

---

# 小坑与注意

1. 你当前的“第一列冻结”逻辑不变：若真实列为 0，则冻结列也就不存在（OK）；当出现真实列时，冻结逻辑继续按原规则工作。
2. `initializeTableData(...)` 如果仍在别的路径被调用，它会创建“有单元格的列”。建议统一由 `ensureTrailingBuildColumns(true)` 兜底，或尽量避免用它初始化空表。
3. 若历史笔记已经有一些列，`loadTableData(...)` 后调用一次 `ensureTrailingBuildColumns(true)`，可自动把散落的 build 列（若有）收拢到末尾并补齐5个。

---

以上就是“**第一步（可直接实现）** + **第二步（准备好一键切换隐藏列头）**”的完整方案。
如果你要我把上述改动点在你这份源码里全部打补丁，我可以继续给出**逐函数的完整替换片段**；或者你先让 Claude 按上面片段落地，我们再一起做 Step 2 的 UI 隐藏小改动。
