下面把两个问题的“根因 → 方案”讲清楚，并给出最少改动的补丁路径和更稳妥的重构路径。你可以把其中一种交给 Claude 去落地。

---

## 问题 1：从倒序切回“默认排序”时无效

**根因（代码层面）**

* 你在 `sortByColumn()` 里调用
  `buildFullGrid(frozen, scrollable, rows, cols)`，这里传入的是**当前用于显示的 LiveData 列表**（`_frozenColumnCells/_scrollableColumnsCells`）。
  之前一次排序结束后，这两个列表已经被 `emitGridInOrder()` 用“展示副本”覆盖了（而且副本里的 `rowIndex` 也改成了展示行号）。
* 当你再切回“默认排序”（分支里 `order = argsortByArray(originalRowOrder)` 实际就是 `[0..n-1]`）时，**基底 grid 已经是“上一次排序后的顺序”**，再给它套一个 `[0..n-1]` 的 order，自然什么都不会变。

**最小改动补丁（不动数据库 / 不动 UI）：分离“源数据”与“展示数据”**

1. **新增两份只读的源数据缓存**，只在“加载 / 增删结构”时更新，排序时**永不改动**：

   ```java
   // 永久源数据（排序不改它）
   private List<Cell> sourceFrozenCells = new ArrayList<>();
   private List<Cell> sourceScrollableCells = new ArrayList<>();
   ```
2. 在 `loadCellData()` 里，计算完 `frozenCells/scrollableCells` 后：

   ```java
   sourceFrozenCells = deepCopyCells(frozenCells);
   sourceScrollableCells = deepCopyCells(scrollableCells);
   // 初次展示用源数据 + 原始顺序
   List<List<Cell>> grid = buildFullGrid(sourceFrozenCells, sourceScrollableCells, rows, cols);
   int[] identity = new int[rows]; for (int i=0;i<rows;i++) identity[i]=i;
   emitGridInOrder(grid, identity);
   ```

   > `deepCopyCells` 用你现有的 `createCellCopy` 即可。
3. 在 `sortByColumn()` 的三个分支里，**一律**用源数据构建 grid：

   ```java
   List<List<Cell>> grid = buildFullGrid(sourceFrozenCells, sourceScrollableCells, rows, cols);
   ```
4. 切回默认排序的分支，直接用 **identity**（或者用 `originalRowOrder` 计算出来的次序），但**基底 grid 一定来自 source\***，这样才能回到创建时顺序：

   ```java
   int[] order = new int[rows];
   for (int i=0;i<rows;i++) order[i]=i;        // 默认=创建顺序
   emitGridInOrder(buildFullGrid(sourceFrozenCells, sourceScrollableCells, rows, cols), order);
   currentRowOrder = order.clone();
   ```
5. 在 **所有结构性变更**里也要同步维护 `source*`：

   * `initializeTableData()`：同时填充 `source*`
   * `addNewRow()/insertRowAt()/deleteRowAt()`：在改 `_frozen/_scrollable` 的同时，同步改 `source*`
   * `addNewColumn()/insertColumnAt()/deleteColumnAt()`：同理
     这样“默认排序=回到 source\* 的顺序”的语义始终成立。

> 这样做不需要重新查库，也不依赖 `originalRowOrder` 的正确性（它也可以保留用于更复杂的“行键”语义，见下文重构方案）。

---

## 问题 2：对某一列排序时，没有“整行联动”，只那一列动了

**现象解释**

* 你的 `emitGridInOrder()` 其实是**按整行**输出新列表的：它对每个 `newRow` 把该行所有列都复制到 `newFrozen/newScrollable`。逻辑上是对的。
* 但在实际 UI 上只看到“列1动了”，常见原因有两类（任一命中都会出现你描述的症状）：

  **A. 用 DiffUtil/ListAdapter，但“展示副本”没有稳定的 itemId/equals**

  * 你在 `createDisplayCopy()` 明确写了“不复制 id”，于是**所有副本的 id 都是 0/null**，DiffUtil 会把它们当作“同一条”，从而**不触发移动**，视觉上就好像其它列没动。

  **B. 排序用的基底 grid 取自当前 LiveData（上一轮的展示副本）**

  * 这会导致“同一列再次被重算且替换为新副本”，而其它列由于 DiffUtil 判断“没变”，就不刷新。
  * 这个问题也与问题 1 的根因相同——用展示列表作为基底。

**解决方案**

* **必须给每个“展示副本”一个稳定且唯一的 itemId**（不一定用数据库 id）。推荐用“行键 + 列索引”拼出来的临时 id：

  ```java
  // 建议引入稳定行键 rowKey（见下一节重构），没有的话可用 oldRow 作为近似
  long tempId = ((long) rowKey << 20) | (cell.getColIndex() & 0xFFFFF);
  copy.setId(tempId); // 若 setId 会影响 DB，改为 setTempId 或在 Adapter 中单独提供 getItemId
  ```

  * 如果你用的是 `RecyclerView.Adapter.setHasStableIds(true)` 或 `ListAdapter`，务必在 `getItemId()` 里返回这个稳定 id。
  * 如果暂时不方便，**退一步**：直接在排序后对两个适配器使用 `notifyDataSetChanged()` 验证联动是否生效，若生效再回到稳定 id 的实现。
* 配合上面“源/展分离”的补丁，`emitGridInOrder()` 每次都是“整行替换 + 稳定 id”，DiffUtil 就能正确地产生**整行移动动画**，视觉上也就是“整行联动排序”。

---

## 更稳妥的重构（推荐）：引入“行键（rowId/rowKey）”与行模型

最小补丁能解决当前两个 bug，但要彻底干净、后续好维护，建议：

1. **用 Row 作为内存主模型**（而非散落的两个 Cell 列表）：

   ```java
   static final class Row {
       final int rowKey;               // 稳定不变的行键（内存层面可用自增）
       final Cell frozen;              // col 0
       final List<Cell> cells;         // col 1..N-1
   }
   private List<Row> masterRows = new ArrayList<>(); // 只在加载/增删结构时改
   private int[] originalOrder;  // rowKey 按创建顺序
   private int[] currentOrder;   // rowKey 按当前显示顺序
   ```
2. **排序只改 `currentOrder`**，不改 `masterRows`：

   * 取比较值：`Row r = rowMap.get(rowKey);` → 拿 `r.frozen` 或 `r.cells.get(columnIndex-1)` 的内容。
   * **空值永远置尾**、`DESC` 反向，保持稳定排序。
3. **发射展示数据**：由 `currentOrder` 逐行把 `masterRows` 展成两个扁平的 `List<Cell>`（用你现有的 `emitGridInOrder` 思路即可）。
   `createDisplayCopy()` 里按「`rowKey + colIndex`」生成稳定 id。
4. **默认排序**：`currentOrder = originalOrder.clone(); emit()`，一定生效。
5. **增删行**：给新行分配新的 `rowKey`，插入到 `masterRows`；同时用你已有的 `insertKey/removeKey()` 或直接改 `originalOrder/currentOrder` 维护行序。
6. **编辑**：直接改 `masterRows` 里的单元格；是否立刻 `emit` 由你的交互决定；落库照旧。

> 好处：
>
> * 行有了稳定身份，排序、筛选、拖拽、撤销/重做都将更简单。
> * DiffUtil 可用稳定 id 做“移动”动画，而不是整表重刷。

---

## 比较器与类型感知（可选但强烈建议）

你现在的比较器是“数字优先，否则字典序”，可以加强为**列类型感知**：

* 若列 `Column.type` 为 `NUMBER/DATE/BOOLEAN/IMAGE/TEXT`，走对应解析。否则回退到“数字优先”启发式。
* `tryParseNumber()` 建议增强：

  * 处理负号与括号：`(1,234)` → `-1234`
  * 允许空格与本地化小数点
  * 货币/百分号已覆盖，保留
* 日期解析：支持常见格式（`yyyy-MM-dd`、`yyyy/MM/dd`、`yyyy.MM.dd`、`yyyy年MM月dd日` 等），无法解析则按字符串。

---

## 与现有代码的具体改动点清单（交给 Claude 实现即可）

**A. 新增字段**

```java
private List<Cell> sourceFrozenCells = new ArrayList<>();
private List<Cell> sourceScrollableCells = new ArrayList<>();
```

**B. `loadCellData()` 里：**

* 生成 `frozenCells/scrollableCells` 后：

```java
sourceFrozenCells = deepCopyCells(frozenCells);
sourceScrollableCells = deepCopyCells(scrollableCells);

_rowCount.postValue(rows);
_columnCount.postValue(cols);

// 用源数据 + identity 发射
int[] identity = new int[rows]; for (int i=0;i<rows;i++) identity[i]=i;
emitGridInOrder(buildFullGrid(sourceFrozenCells, sourceScrollableCells, rows, cols), identity);

// 初始化 originalRowOrder/currentRowOrder（按需要保留）
originalRowOrder = identity.clone();
currentRowOrder  = identity.clone();
```

**C. `sortByColumn()` 里：**

* **统一改为**

```java
List<List<Cell>> grid = buildFullGrid(sourceFrozenCells, sourceScrollableCells, rows, cols);
```

* 默认分支直接：

```java
int[] order = new int[rows]; for (int i=0;i<rows;i++) order[i]=i;
currentRowOrder = order.clone();
emitGridInOrder(grid, order);
```

**D. `emitGridInOrder()` 里：**

* 在 `createDisplayCopy()` 之后给“展示副本”设置稳定 id（如果 `Cell` 的 `id` 不能用于临时 id，给 Adapter 提供 `getItemId()`）：

```java
// 需要有 rowKey，可用 oldRow 代替过渡一下
long tempId = (((long) oldRow) << 20) | c; // oldRow = rowOrder[newRow], c = 列索引
copied.setId(tempId); // 或者 copied.setTempId(tempId)，由 UI 层读取
```

**E. 结构性变更（增删行列）**

* 在 `initializeTableData/addNewRow/insertRowAt/deleteRowAt/addNewColumn/...` 中，**同步修改 `source*`**（与修改 `_frozen/_scrollable` 同步）。
* 同时调用你已有的 `insertKey/removeKey()` 维护 `originalRowOrder/currentRowOrder`，或直接维护 `currentRowOrder` 的插入/删除。

**F. UI 层（若使用 DiffUtil/ListAdapter）**

* 开启稳定 ID：`adapter.setHasStableIds(true);`
* `getItemId(position)` 返回上文设置的稳定 id（行键 + 列索引）。
* 过渡方案：先直接 `notifyDataSetChanged()` 验证整行联动，确认后再切回 DiffUtil。

---

## 额外增强（可按需做）

* **多列排序**：支持传入 `List<SortSpec>`，逐列比较（稳定排序或一次性比较器都行）。
* **空值位置可配置**：现在你是“空值永远排末尾”，可以允许 `NULLS FIRST/LAST`。
* **排序状态记忆**：将 `currentRowOrder` 与各列排序状态保存在 ViewModel，以便回到页面能还原。

---

### 小结

* **问题 1** 的关键是**不要拿“展示副本”当排序基底**；要有一份**不被排序改写的源数据**，默认排序从它发射即可。
* **问题 2** 多半是 **DiffUtil + 无稳定 id** 与 **基底取错** 的组合问题；给展示副本稳定 id，并用源数据重建整行，即可让“整行联动排序”如预期工作。

把以上“最小补丁”交给 Claude 实现，就能立刻修复你描述的两个现象；后续再按“行模型 + 行键”的方案重构，会让排序、筛选、撤销/重做、拖拽等能力都更稳更好维护。
