好！下面是一份可以直接丢给 Claude 的**实现说明书/任务清单**（含接口与关键代码骨架）。按这个做，能做出与 DataGrip 类似的“本地筛选器”：搜索、值+计数两列、复选、多选逻辑（未选或全选=显示全部）。

---

# 目标与交互规则

1. 面板样式：顶部搜索框；下方为两列：**值**（含复选框）与**计数**。
2. 计数=当前列每个去重值出现的次数（建议默认基于“当前数据集”，若全局还有其它筛选，计数随之变化）。
3. 选择规则：

   * 未勾选任何值 **或** 勾选了全部值 ⇒ 视为“无筛选”，显示全部；
   * 勾选部分值 ⇒ 只显示这些值所在的行。
4. 搜索仅过滤“候选项列表”；不改变底层数据。
5. 空值以“（空）”显示，内部仍使用 `""` 作为真实值。

---

# 数据结构

```java
// 供 UI 使用的候选项
public final class FilterOption {
    public final String value;     // 实际值；空字符串代表空值
    public final String display;   // 显示文本，空值显示为 "（空）"
    public final int count;        // 计数
    public boolean checked;        // 勾选状态（UI 层可变）
    public FilterOption(String v, int c, boolean chk) {
        this.value = v == null ? "" : v;
        this.display = (this.value.isEmpty() ? "（空）" : this.value);
        this.count = c; this.checked = chk;
    }
}
```

---

# ViewModel 扩展（基于你现有 `NoteViewModel`）

> 关键点：**候选计算使用“源数据”**（上一条回复里建议新增的 `sourceFrozenCells/sourceScrollableCells`），不要用展示副本。

```java
// 1) 生成“值-计数”候选（内存版）
public List<FilterOption> buildValueCountsForColumn(int columnIndex) {
    Map<String, Integer> freq = new HashMap<>();
    // 用源数据，避免受排序/展示副本污染
    List<Cell> pool = new ArrayList<>();
    if (sourceFrozenCells != null) pool.addAll(sourceFrozenCells);
    if (sourceScrollableCells != null) pool.addAll(sourceScrollableCells);

    for (Cell cell : pool) {
        if (cell.getColIndex() != columnIndex) continue;
        String raw = cell.getContent();
        String key = (raw == null ? "" : raw.trim());
        freq.put(key, freq.getOrDefault(key, 0) + 1);
    }
    // 转为列表并排序（计数降序，值字典序）
    List<FilterOption> options = new ArrayList<>();
    for (Map.Entry<String,Integer> e : freq.entrySet()) {
        options.add(new FilterOption(e.getKey(), e.getValue(), false));
    }
    options.sort((a,b) -> {
        int c = Integer.compare(b.count, a.count);
        return c != 0 ? c : a.display.compareToIgnoreCase(b.display);
    });
    return options;
}

// 2) 应用筛选（包装已有的多选接口）
public void applyValueFilter(int columnIndex, List<FilterOption> uiOptions) {
    // 选中的值集合
    Set<String> selected = new HashSet<>();
    int checked = 0;
    for (FilterOption o : uiOptions) {
        if (o.checked) { selected.add(o.value); checked++; }
    }
    // “未选或全选 => 显示全部”
    if (checked == 0 || checked == uiOptions.size()) {
        reloadData(); // 或发射源数据（更快）
        return;
    }
    // 否则用你现有的方法
    filterByColumnValues(columnIndex, selected);
}
```

> （可选）如数据量大、已入库 Room/SQLite，做一个 SQL 版统计接口：
> `SELECT IFNULL(content,'' ) AS value, COUNT(*) AS cnt FROM cells WHERE notebookId=? AND colIndex=? GROUP BY value ORDER BY cnt DESC, value COLLATE NOCASE ASC;`
> 然后把结果映射成 `FilterOption` 列表返回给 UI。

---

# UI：面板与列表

**容器**：推荐 `BottomSheetDialogFragment`（长列表体验更好），或使用 `PopupWindow` 锚定列头。
**列表**：`RecyclerView`（垂直），**单行布局**含：`CheckBox + TextView(值)`、`TextView(计数)`（右对齐）。
**标题行**（“值 | 计数”）可作为 `RecyclerView` 的第 0 行 ViewType 或放在顶部一个 `LinearLayout`。

**布局草稿（行项）**：

```xml
<LinearLayout ... android:padding="8dp">
  <CheckBox android:id="@+id/cb"/>
  <TextView android:id="@+id/tvValue" android:layout_weight="1" android:ellipsize="end"/>
  <TextView android:id="@+id/tvCount" android:gravity="end" android:minWidth="48dp"/>
</LinearLayout>
```

**Adapter 要点**：

* 使用 `ListAdapter<FilterOption, VH>` + `DiffUtil`；
* 开启稳定 ID：`setHasStableIds(true)`，`getItemId()` 用 `value.hashCode()`（或更稳妥的 `value` 的 64 位 hash）。
* 点击行或勾选框，更新 `option.checked`，`notifyItemChanged(position)`。

**搜索框**：

* `EditText` + `TextWatcher`，做 200\~300ms debounce（Java 可用 `Handler` 延迟；Kotlin 可用 `Flow`）。
* 过滤逻辑：在内存 `allOptions` 上执行 `containsIgnoreCase(query)` 生成 `visibleOptions`，提交给 Adapter。
* 不改变 `checked` 状态（只隐藏不匹配项）。

**页脚**（可选）：

* “全选/全不选/反选/重置” 快捷按钮；
* 底部说明 “选择一个复选框来筛选”。

**确定/取消**：

* “确定” → 调 `viewModel.applyValueFilter(columnIndex, adapter.getCurrentList())`
* “取消” → 关闭面板不改状态。

---

# 与现有过滤接口的衔接

* 你已有 `filterByColumnValues(int columnIndex, Set<String> selectedValues)`，直接复用。
* 记得在 `reloadData()` 里复位到**源数据**（不是展示副本），以避免排序/筛选叠加造成回不去。

---

# 边界与细节

* **空值**：UI 显示“（空）”，内部仍用 `""` 传给 `filterByColumnValues`。
* **去重**：使用 `trim()`，必要时提供“大小写不敏感去重”的开关。
* **计数口径**：默认基于“当前数据集”（被其它列筛选后的集合）。若要“全表口径”，给 `buildValueCountsForColumn()` 增加布尔参数切换。
* **性能**：大列（>1e5）优先数据库聚合，或在内存统计时分批遍历 + 提前截断（如只显示前 500 个最常见值）。
* **状态记忆**：`Map<Integer /*colIndex*/, Set<String> /*selectedValues*/>` 存在 ViewModel，打开面板时把 `checked` 初始化到已选项。

---

# 交付验收（给 QA/自测）

1. 默认打开：候选列表完整显示，所有复选框未选；点击“确定”不改变表格。
2. 多选 2\~3 个值：表格只保留这些值所在的行；再次打开面板，状态被正确记忆。
3. 清空选择或全选后确定：恢复显示全部。
4. 搜索关键词过滤候选，但不影响底层数据和已选状态；清空搜索后候选恢复。
5. 与排序联动：无论当前是否排序，筛选都基于**源数据行键**，结果一致。

---

把这份说明给 Claude，让 TA 直接按以上接口和骨架去落地即可。
